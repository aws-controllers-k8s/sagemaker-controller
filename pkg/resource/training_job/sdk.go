// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package training_job

import (
	"context"
	"errors"
	"fmt"
	"math"
	"reflect"
	"strings"

	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	ackcompare "github.com/aws-controllers-k8s/runtime/pkg/compare"
	ackcondition "github.com/aws-controllers-k8s/runtime/pkg/condition"
	ackerr "github.com/aws-controllers-k8s/runtime/pkg/errors"
	ackrequeue "github.com/aws-controllers-k8s/runtime/pkg/requeue"
	ackrtlog "github.com/aws-controllers-k8s/runtime/pkg/runtime/log"
	"github.com/aws/aws-sdk-go-v2/aws"
	svcsdk "github.com/aws/aws-sdk-go-v2/service/sagemaker"
	svcsdktypes "github.com/aws/aws-sdk-go-v2/service/sagemaker/types"
	smithy "github.com/aws/smithy-go"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	svcapitypes "github.com/aws-controllers-k8s/sagemaker-controller/apis/v1alpha1"
)

// Hack to avoid import errors during build...
var (
	_ = &metav1.Time{}
	_ = strings.ToLower("")
	_ = &svcsdk.Client{}
	_ = &svcapitypes.TrainingJob{}
	_ = ackv1alpha1.AWSAccountID("")
	_ = &ackerr.NotFound
	_ = &ackcondition.NotManagedMessage
	_ = &reflect.Value{}
	_ = fmt.Sprintf("")
	_ = &ackrequeue.NoRequeue{}
	_ = &aws.Config{}
)

// sdkFind returns SDK-specific information about a supplied resource
func (rm *resourceManager) sdkFind(
	ctx context.Context,
	r *resource,
) (latest *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkFind")
	defer func() {
		exit(err)
	}()
	// If any required fields in the input shape are missing, AWS resource is
	// not created yet. Return NotFound here to indicate to callers that the
	// resource isn't yet created.
	if rm.requiredFieldsMissingFromReadOneInput(r) {
		return nil, ackerr.NotFound
	}

	input, err := rm.newDescribeRequestPayload(r)
	if err != nil {
		return nil, err
	}

	var resp *svcsdk.DescribeTrainingJobOutput
	resp, err = rm.sdkapi.DescribeTrainingJob(ctx, input)
	rm.metrics.RecordAPICall("READ_ONE", "DescribeTrainingJob", err)
	if err != nil {
		var awsErr smithy.APIError
		if errors.As(err, &awsErr) && awsErr.ErrorCode() == "ValidationException" && strings.HasPrefix(awsErr.ErrorMessage(), "Requested resource not found") {
			return nil, ackerr.NotFound
		}
		return nil, err
	}

	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := r.ko.DeepCopy()

	if resp.AlgorithmSpecification != nil {
		f0 := &svcapitypes.AlgorithmSpecification{}
		if resp.AlgorithmSpecification.AlgorithmName != nil {
			f0.AlgorithmName = resp.AlgorithmSpecification.AlgorithmName
		}
		if resp.AlgorithmSpecification.EnableSageMakerMetricsTimeSeries != nil {
			f0.EnableSageMakerMetricsTimeSeries = resp.AlgorithmSpecification.EnableSageMakerMetricsTimeSeries
		}
		if resp.AlgorithmSpecification.MetricDefinitions != nil {
			f0f2 := []*svcapitypes.MetricDefinition{}
			for _, f0f2iter := range resp.AlgorithmSpecification.MetricDefinitions {
				f0f2elem := &svcapitypes.MetricDefinition{}
				if f0f2iter.Name != nil {
					f0f2elem.Name = f0f2iter.Name
				}
				if f0f2iter.Regex != nil {
					f0f2elem.Regex = f0f2iter.Regex
				}
				f0f2 = append(f0f2, f0f2elem)
			}
			f0.MetricDefinitions = f0f2
		}
		if resp.AlgorithmSpecification.TrainingImage != nil {
			f0.TrainingImage = resp.AlgorithmSpecification.TrainingImage
		}
		if resp.AlgorithmSpecification.TrainingInputMode != "" {
			f0.TrainingInputMode = aws.String(string(resp.AlgorithmSpecification.TrainingInputMode))
		}
		ko.Spec.AlgorithmSpecification = f0
	} else {
		ko.Spec.AlgorithmSpecification = nil
	}
	if resp.CheckpointConfig != nil {
		f3 := &svcapitypes.CheckpointConfig{}
		if resp.CheckpointConfig.LocalPath != nil {
			f3.LocalPath = resp.CheckpointConfig.LocalPath
		}
		if resp.CheckpointConfig.S3Uri != nil {
			f3.S3URI = resp.CheckpointConfig.S3Uri
		}
		ko.Spec.CheckpointConfig = f3
	} else {
		ko.Spec.CheckpointConfig = nil
	}
	if resp.CreationTime != nil {
		ko.Status.CreationTime = &metav1.Time{*resp.CreationTime}
	} else {
		ko.Status.CreationTime = nil
	}
	if resp.DebugHookConfig != nil {
		f5 := &svcapitypes.DebugHookConfig{}
		if resp.DebugHookConfig.CollectionConfigurations != nil {
			f5f0 := []*svcapitypes.CollectionConfiguration{}
			for _, f5f0iter := range resp.DebugHookConfig.CollectionConfigurations {
				f5f0elem := &svcapitypes.CollectionConfiguration{}
				if f5f0iter.CollectionName != nil {
					f5f0elem.CollectionName = f5f0iter.CollectionName
				}
				if f5f0iter.CollectionParameters != nil {
					f5f0elem.CollectionParameters = aws.StringMap(f5f0iter.CollectionParameters)
				}
				f5f0 = append(f5f0, f5f0elem)
			}
			f5.CollectionConfigurations = f5f0
		}
		if resp.DebugHookConfig.HookParameters != nil {
			f5.HookParameters = aws.StringMap(resp.DebugHookConfig.HookParameters)
		}
		if resp.DebugHookConfig.LocalPath != nil {
			f5.LocalPath = resp.DebugHookConfig.LocalPath
		}
		if resp.DebugHookConfig.S3OutputPath != nil {
			f5.S3OutputPath = resp.DebugHookConfig.S3OutputPath
		}
		ko.Spec.DebugHookConfig = f5
	} else {
		ko.Spec.DebugHookConfig = nil
	}
	if resp.DebugRuleConfigurations != nil {
		f6 := []*svcapitypes.DebugRuleConfiguration{}
		for _, f6iter := range resp.DebugRuleConfigurations {
			f6elem := &svcapitypes.DebugRuleConfiguration{}
			if f6iter.InstanceType != "" {
				f6elem.InstanceType = aws.String(string(f6iter.InstanceType))
			}
			if f6iter.LocalPath != nil {
				f6elem.LocalPath = f6iter.LocalPath
			}
			if f6iter.RuleConfigurationName != nil {
				f6elem.RuleConfigurationName = f6iter.RuleConfigurationName
			}
			if f6iter.RuleEvaluatorImage != nil {
				f6elem.RuleEvaluatorImage = f6iter.RuleEvaluatorImage
			}
			if f6iter.RuleParameters != nil {
				f6elem.RuleParameters = aws.StringMap(f6iter.RuleParameters)
			}
			if f6iter.S3OutputPath != nil {
				f6elem.S3OutputPath = f6iter.S3OutputPath
			}
			if f6iter.VolumeSizeInGB != nil {
				volumeSizeInGBCopy := int64(*f6iter.VolumeSizeInGB)
				f6elem.VolumeSizeInGB = &volumeSizeInGBCopy
			}
			f6 = append(f6, f6elem)
		}
		ko.Spec.DebugRuleConfigurations = f6
	} else {
		ko.Spec.DebugRuleConfigurations = nil
	}
	if resp.DebugRuleEvaluationStatuses != nil {
		f7 := []*svcapitypes.DebugRuleEvaluationStatus{}
		for _, f7iter := range resp.DebugRuleEvaluationStatuses {
			f7elem := &svcapitypes.DebugRuleEvaluationStatus{}
			if f7iter.LastModifiedTime != nil {
				f7elem.LastModifiedTime = &metav1.Time{*f7iter.LastModifiedTime}
			}
			if f7iter.RuleConfigurationName != nil {
				f7elem.RuleConfigurationName = f7iter.RuleConfigurationName
			}
			if f7iter.RuleEvaluationJobArn != nil {
				f7elem.RuleEvaluationJobARN = f7iter.RuleEvaluationJobArn
			}
			if f7iter.RuleEvaluationStatus != "" {
				f7elem.RuleEvaluationStatus = aws.String(string(f7iter.RuleEvaluationStatus))
			}
			if f7iter.StatusDetails != nil {
				f7elem.StatusDetails = f7iter.StatusDetails
			}
			f7 = append(f7, f7elem)
		}
		ko.Status.DebugRuleEvaluationStatuses = f7
	} else {
		ko.Status.DebugRuleEvaluationStatuses = nil
	}
	if resp.EnableInterContainerTrafficEncryption != nil {
		ko.Spec.EnableInterContainerTrafficEncryption = resp.EnableInterContainerTrafficEncryption
	} else {
		ko.Spec.EnableInterContainerTrafficEncryption = nil
	}
	if resp.EnableManagedSpotTraining != nil {
		ko.Spec.EnableManagedSpotTraining = resp.EnableManagedSpotTraining
	} else {
		ko.Spec.EnableManagedSpotTraining = nil
	}
	if resp.EnableNetworkIsolation != nil {
		ko.Spec.EnableNetworkIsolation = resp.EnableNetworkIsolation
	} else {
		ko.Spec.EnableNetworkIsolation = nil
	}
	if resp.Environment != nil {
		ko.Spec.Environment = aws.StringMap(resp.Environment)
	} else {
		ko.Spec.Environment = nil
	}
	if resp.ExperimentConfig != nil {
		f12 := &svcapitypes.ExperimentConfig{}
		if resp.ExperimentConfig.ExperimentName != nil {
			f12.ExperimentName = resp.ExperimentConfig.ExperimentName
		}
		if resp.ExperimentConfig.TrialComponentDisplayName != nil {
			f12.TrialComponentDisplayName = resp.ExperimentConfig.TrialComponentDisplayName
		}
		if resp.ExperimentConfig.TrialName != nil {
			f12.TrialName = resp.ExperimentConfig.TrialName
		}
		ko.Spec.ExperimentConfig = f12
	} else {
		ko.Spec.ExperimentConfig = nil
	}
	if resp.FailureReason != nil {
		ko.Status.FailureReason = resp.FailureReason
	} else {
		ko.Status.FailureReason = nil
	}
	if resp.HyperParameters != nil {
		ko.Spec.HyperParameters = aws.StringMap(resp.HyperParameters)
	} else {
		ko.Spec.HyperParameters = nil
	}
	if resp.InfraCheckConfig != nil {
		f16 := &svcapitypes.InfraCheckConfig{}
		if resp.InfraCheckConfig.EnableInfraCheck != nil {
			f16.EnableInfraCheck = resp.InfraCheckConfig.EnableInfraCheck
		}
		ko.Spec.InfraCheckConfig = f16
	} else {
		ko.Spec.InfraCheckConfig = nil
	}
	if resp.InputDataConfig != nil {
		f17 := []*svcapitypes.Channel{}
		for _, f17iter := range resp.InputDataConfig {
			f17elem := &svcapitypes.Channel{}
			if f17iter.ChannelName != nil {
				f17elem.ChannelName = f17iter.ChannelName
			}
			if f17iter.CompressionType != "" {
				f17elem.CompressionType = aws.String(string(f17iter.CompressionType))
			}
			if f17iter.ContentType != nil {
				f17elem.ContentType = f17iter.ContentType
			}
			if f17iter.DataSource != nil {
				f17elemf3 := &svcapitypes.DataSource{}
				if f17iter.DataSource.FileSystemDataSource != nil {
					f17elemf3f0 := &svcapitypes.FileSystemDataSource{}
					if f17iter.DataSource.FileSystemDataSource.DirectoryPath != nil {
						f17elemf3f0.DirectoryPath = f17iter.DataSource.FileSystemDataSource.DirectoryPath
					}
					if f17iter.DataSource.FileSystemDataSource.FileSystemAccessMode != "" {
						f17elemf3f0.FileSystemAccessMode = aws.String(string(f17iter.DataSource.FileSystemDataSource.FileSystemAccessMode))
					}
					if f17iter.DataSource.FileSystemDataSource.FileSystemId != nil {
						f17elemf3f0.FileSystemID = f17iter.DataSource.FileSystemDataSource.FileSystemId
					}
					if f17iter.DataSource.FileSystemDataSource.FileSystemType != "" {
						f17elemf3f0.FileSystemType = aws.String(string(f17iter.DataSource.FileSystemDataSource.FileSystemType))
					}
					f17elemf3.FileSystemDataSource = f17elemf3f0
				}
				if f17iter.DataSource.S3DataSource != nil {
					f17elemf3f1 := &svcapitypes.S3DataSource{}
					if f17iter.DataSource.S3DataSource.AttributeNames != nil {
						f17elemf3f1.AttributeNames = aws.StringSlice(f17iter.DataSource.S3DataSource.AttributeNames)
					}
					if f17iter.DataSource.S3DataSource.InstanceGroupNames != nil {
						f17elemf3f1.InstanceGroupNames = aws.StringSlice(f17iter.DataSource.S3DataSource.InstanceGroupNames)
					}
					if f17iter.DataSource.S3DataSource.S3DataDistributionType != "" {
						f17elemf3f1.S3DataDistributionType = aws.String(string(f17iter.DataSource.S3DataSource.S3DataDistributionType))
					}
					if f17iter.DataSource.S3DataSource.S3DataType != "" {
						f17elemf3f1.S3DataType = aws.String(string(f17iter.DataSource.S3DataSource.S3DataType))
					}
					if f17iter.DataSource.S3DataSource.S3Uri != nil {
						f17elemf3f1.S3URI = f17iter.DataSource.S3DataSource.S3Uri
					}
					f17elemf3.S3DataSource = f17elemf3f1
				}
				f17elem.DataSource = f17elemf3
			}
			if f17iter.InputMode != "" {
				f17elem.InputMode = aws.String(string(f17iter.InputMode))
			}
			if f17iter.RecordWrapperType != "" {
				f17elem.RecordWrapperType = aws.String(string(f17iter.RecordWrapperType))
			}
			if f17iter.ShuffleConfig != nil {
				f17elemf6 := &svcapitypes.ShuffleConfig{}
				if f17iter.ShuffleConfig.Seed != nil {
					f17elemf6.Seed = f17iter.ShuffleConfig.Seed
				}
				f17elem.ShuffleConfig = f17elemf6
			}
			f17 = append(f17, f17elem)
		}
		ko.Spec.InputDataConfig = f17
	} else {
		ko.Spec.InputDataConfig = nil
	}
	if resp.LastModifiedTime != nil {
		ko.Status.LastModifiedTime = &metav1.Time{*resp.LastModifiedTime}
	} else {
		ko.Status.LastModifiedTime = nil
	}
	if resp.ModelArtifacts != nil {
		f20 := &svcapitypes.ModelArtifacts{}
		if resp.ModelArtifacts.S3ModelArtifacts != nil {
			f20.S3ModelArtifacts = resp.ModelArtifacts.S3ModelArtifacts
		}
		ko.Status.ModelArtifacts = f20
	} else {
		ko.Status.ModelArtifacts = nil
	}
	if resp.OutputDataConfig != nil {
		f21 := &svcapitypes.OutputDataConfig{}
		if resp.OutputDataConfig.CompressionType != "" {
			f21.CompressionType = aws.String(string(resp.OutputDataConfig.CompressionType))
		}
		if resp.OutputDataConfig.KmsKeyId != nil {
			f21.KMSKeyID = resp.OutputDataConfig.KmsKeyId
		}
		if resp.OutputDataConfig.S3OutputPath != nil {
			f21.S3OutputPath = resp.OutputDataConfig.S3OutputPath
		}
		ko.Spec.OutputDataConfig = f21
	} else {
		ko.Spec.OutputDataConfig = nil
	}
	if resp.ProfilerConfig != nil {
		f22 := &svcapitypes.ProfilerConfig{}
		if resp.ProfilerConfig.ProfilingIntervalInMilliseconds != nil {
			f22.ProfilingIntervalInMilliseconds = resp.ProfilerConfig.ProfilingIntervalInMilliseconds
		}
		if resp.ProfilerConfig.ProfilingParameters != nil {
			f22.ProfilingParameters = aws.StringMap(resp.ProfilerConfig.ProfilingParameters)
		}
		if resp.ProfilerConfig.S3OutputPath != nil {
			f22.S3OutputPath = resp.ProfilerConfig.S3OutputPath
		}
		ko.Spec.ProfilerConfig = f22
	} else {
		ko.Spec.ProfilerConfig = nil
	}
	if resp.ProfilerRuleConfigurations != nil {
		f23 := []*svcapitypes.ProfilerRuleConfiguration{}
		for _, f23iter := range resp.ProfilerRuleConfigurations {
			f23elem := &svcapitypes.ProfilerRuleConfiguration{}
			if f23iter.InstanceType != "" {
				f23elem.InstanceType = aws.String(string(f23iter.InstanceType))
			}
			if f23iter.LocalPath != nil {
				f23elem.LocalPath = f23iter.LocalPath
			}
			if f23iter.RuleConfigurationName != nil {
				f23elem.RuleConfigurationName = f23iter.RuleConfigurationName
			}
			if f23iter.RuleEvaluatorImage != nil {
				f23elem.RuleEvaluatorImage = f23iter.RuleEvaluatorImage
			}
			if f23iter.RuleParameters != nil {
				f23elem.RuleParameters = aws.StringMap(f23iter.RuleParameters)
			}
			if f23iter.S3OutputPath != nil {
				f23elem.S3OutputPath = f23iter.S3OutputPath
			}
			if f23iter.VolumeSizeInGB != nil {
				volumeSizeInGBCopy := int64(*f23iter.VolumeSizeInGB)
				f23elem.VolumeSizeInGB = &volumeSizeInGBCopy
			}
			f23 = append(f23, f23elem)
		}
		ko.Spec.ProfilerRuleConfigurations = f23
	} else {
		ko.Spec.ProfilerRuleConfigurations = nil
	}
	if resp.ProfilerRuleEvaluationStatuses != nil {
		f24 := []*svcapitypes.ProfilerRuleEvaluationStatus{}
		for _, f24iter := range resp.ProfilerRuleEvaluationStatuses {
			f24elem := &svcapitypes.ProfilerRuleEvaluationStatus{}
			if f24iter.LastModifiedTime != nil {
				f24elem.LastModifiedTime = &metav1.Time{*f24iter.LastModifiedTime}
			}
			if f24iter.RuleConfigurationName != nil {
				f24elem.RuleConfigurationName = f24iter.RuleConfigurationName
			}
			if f24iter.RuleEvaluationJobArn != nil {
				f24elem.RuleEvaluationJobARN = f24iter.RuleEvaluationJobArn
			}
			if f24iter.RuleEvaluationStatus != "" {
				f24elem.RuleEvaluationStatus = aws.String(string(f24iter.RuleEvaluationStatus))
			}
			if f24iter.StatusDetails != nil {
				f24elem.StatusDetails = f24iter.StatusDetails
			}
			f24 = append(f24, f24elem)
		}
		ko.Status.ProfilerRuleEvaluationStatuses = f24
	} else {
		ko.Status.ProfilerRuleEvaluationStatuses = nil
	}
	if resp.ProfilingStatus != "" {
		ko.Status.ProfilingStatus = aws.String(string(resp.ProfilingStatus))
	} else {
		ko.Status.ProfilingStatus = nil
	}
	if resp.RemoteDebugConfig != nil {
		f26 := &svcapitypes.RemoteDebugConfig{}
		if resp.RemoteDebugConfig.EnableRemoteDebug != nil {
			f26.EnableRemoteDebug = resp.RemoteDebugConfig.EnableRemoteDebug
		}
		ko.Spec.RemoteDebugConfig = f26
	} else {
		ko.Spec.RemoteDebugConfig = nil
	}
	if resp.ResourceConfig != nil {
		f27 := &svcapitypes.ResourceConfig{}
		if resp.ResourceConfig.InstanceCount != nil {
			instanceCountCopy := int64(*resp.ResourceConfig.InstanceCount)
			f27.InstanceCount = &instanceCountCopy
		}
		if resp.ResourceConfig.InstanceGroups != nil {
			f27f1 := []*svcapitypes.InstanceGroup{}
			for _, f27f1iter := range resp.ResourceConfig.InstanceGroups {
				f27f1elem := &svcapitypes.InstanceGroup{}
				if f27f1iter.InstanceCount != nil {
					instanceCountCopy := int64(*f27f1iter.InstanceCount)
					f27f1elem.InstanceCount = &instanceCountCopy
				}
				if f27f1iter.InstanceGroupName != nil {
					f27f1elem.InstanceGroupName = f27f1iter.InstanceGroupName
				}
				if f27f1iter.InstanceType != "" {
					f27f1elem.InstanceType = aws.String(string(f27f1iter.InstanceType))
				}
				f27f1 = append(f27f1, f27f1elem)
			}
			f27.InstanceGroups = f27f1
		}
		if resp.ResourceConfig.InstanceType != "" {
			f27.InstanceType = aws.String(string(resp.ResourceConfig.InstanceType))
		}
		if resp.ResourceConfig.KeepAlivePeriodInSeconds != nil {
			keepAlivePeriodInSecondsCopy := int64(*resp.ResourceConfig.KeepAlivePeriodInSeconds)
			f27.KeepAlivePeriodInSeconds = &keepAlivePeriodInSecondsCopy
		}
		if resp.ResourceConfig.VolumeKmsKeyId != nil {
			f27.VolumeKMSKeyID = resp.ResourceConfig.VolumeKmsKeyId
		}
		if resp.ResourceConfig.VolumeSizeInGB != nil {
			volumeSizeInGBCopy := int64(*resp.ResourceConfig.VolumeSizeInGB)
			f27.VolumeSizeInGB = &volumeSizeInGBCopy
		}
		ko.Spec.ResourceConfig = f27
	} else {
		ko.Spec.ResourceConfig = nil
	}
	if resp.RetryStrategy != nil {
		f28 := &svcapitypes.RetryStrategy{}
		if resp.RetryStrategy.MaximumRetryAttempts != nil {
			maximumRetryAttemptsCopy := int64(*resp.RetryStrategy.MaximumRetryAttempts)
			f28.MaximumRetryAttempts = &maximumRetryAttemptsCopy
		}
		ko.Spec.RetryStrategy = f28
	} else {
		ko.Spec.RetryStrategy = nil
	}
	if resp.RoleArn != nil {
		ko.Spec.RoleARN = resp.RoleArn
	} else {
		ko.Spec.RoleARN = nil
	}
	if resp.SecondaryStatus != "" {
		ko.Status.SecondaryStatus = aws.String(string(resp.SecondaryStatus))
	} else {
		ko.Status.SecondaryStatus = nil
	}
	if resp.StoppingCondition != nil {
		f32 := &svcapitypes.StoppingCondition{}
		if resp.StoppingCondition.MaxPendingTimeInSeconds != nil {
			maxPendingTimeInSecondsCopy := int64(*resp.StoppingCondition.MaxPendingTimeInSeconds)
			f32.MaxPendingTimeInSeconds = &maxPendingTimeInSecondsCopy
		}
		if resp.StoppingCondition.MaxRuntimeInSeconds != nil {
			maxRuntimeInSecondsCopy := int64(*resp.StoppingCondition.MaxRuntimeInSeconds)
			f32.MaxRuntimeInSeconds = &maxRuntimeInSecondsCopy
		}
		if resp.StoppingCondition.MaxWaitTimeInSeconds != nil {
			maxWaitTimeInSecondsCopy := int64(*resp.StoppingCondition.MaxWaitTimeInSeconds)
			f32.MaxWaitTimeInSeconds = &maxWaitTimeInSecondsCopy
		}
		ko.Spec.StoppingCondition = f32
	} else {
		ko.Spec.StoppingCondition = nil
	}
	if resp.TensorBoardOutputConfig != nil {
		f33 := &svcapitypes.TensorBoardOutputConfig{}
		if resp.TensorBoardOutputConfig.LocalPath != nil {
			f33.LocalPath = resp.TensorBoardOutputConfig.LocalPath
		}
		if resp.TensorBoardOutputConfig.S3OutputPath != nil {
			f33.S3OutputPath = resp.TensorBoardOutputConfig.S3OutputPath
		}
		ko.Spec.TensorBoardOutputConfig = f33
	} else {
		ko.Spec.TensorBoardOutputConfig = nil
	}
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if resp.TrainingJobArn != nil {
		arn := ackv1alpha1.AWSResourceName(*resp.TrainingJobArn)
		ko.Status.ACKResourceMetadata.ARN = &arn
	}
	if resp.TrainingJobName != nil {
		ko.Spec.TrainingJobName = resp.TrainingJobName
	} else {
		ko.Spec.TrainingJobName = nil
	}
	if resp.TrainingJobStatus != "" {
		ko.Status.TrainingJobStatus = aws.String(string(resp.TrainingJobStatus))
	} else {
		ko.Status.TrainingJobStatus = nil
	}
	if resp.VpcConfig != nil {
		f41 := &svcapitypes.VPCConfig{}
		if resp.VpcConfig.SecurityGroupIds != nil {
			f41.SecurityGroupIDs = aws.StringSlice(resp.VpcConfig.SecurityGroupIds)
		}
		if resp.VpcConfig.Subnets != nil {
			f41.Subnets = aws.StringSlice(resp.VpcConfig.Subnets)
		}
		ko.Spec.VPCConfig = f41
	} else {
		ko.Spec.VPCConfig = nil
	}
	if resp.WarmPoolStatus != nil {
		f42 := &svcapitypes.WarmPoolStatus{}
		if resp.WarmPoolStatus.ResourceRetainedBillableTimeInSeconds != nil {
			resourceRetainedBillableTimeInSecondsCopy := int64(*resp.WarmPoolStatus.ResourceRetainedBillableTimeInSeconds)
			f42.ResourceRetainedBillableTimeInSeconds = &resourceRetainedBillableTimeInSecondsCopy
		}
		if resp.WarmPoolStatus.ReusedByJob != nil {
			f42.ReusedByJob = resp.WarmPoolStatus.ReusedByJob
		}
		if resp.WarmPoolStatus.Status != "" {
			f42.Status = aws.String(string(resp.WarmPoolStatus.Status))
		}
		ko.Status.WarmPoolStatus = f42
	} else {
		ko.Status.WarmPoolStatus = nil
	}

	rm.setStatusDefaults(ko)
	rm.customSetOutput(&resource{ko})
	return &resource{ko}, nil
}

// requiredFieldsMissingFromReadOneInput returns true if there are any fields
// for the ReadOne Input shape that are required but not present in the
// resource's Spec or Status
func (rm *resourceManager) requiredFieldsMissingFromReadOneInput(
	r *resource,
) bool {
	return r.ko.Spec.TrainingJobName == nil

}

// newDescribeRequestPayload returns SDK-specific struct for the HTTP request
// payload of the Describe API call for the resource
func (rm *resourceManager) newDescribeRequestPayload(
	r *resource,
) (*svcsdk.DescribeTrainingJobInput, error) {
	res := &svcsdk.DescribeTrainingJobInput{}

	if r.ko.Spec.TrainingJobName != nil {
		res.TrainingJobName = r.ko.Spec.TrainingJobName
	}

	return res, nil
}

// sdkCreate creates the supplied resource in the backend AWS service API and
// returns a copy of the resource with resource fields (in both Spec and
// Status) filled in with values from the CREATE API operation's Output shape.
func (rm *resourceManager) sdkCreate(
	ctx context.Context,
	desired *resource,
) (created *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkCreate")
	defer func() {
		exit(err)
	}()
	input, err := rm.newCreateRequestPayload(ctx, desired)
	if err != nil {
		return nil, err
	}

	var resp *svcsdk.CreateTrainingJobOutput
	_ = resp
	resp, err = rm.sdkapi.CreateTrainingJob(ctx, input)
	rm.metrics.RecordAPICall("CREATE", "CreateTrainingJob", err)
	if err != nil {
		return nil, err
	}
	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := desired.ko.DeepCopy()

	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if resp.TrainingJobArn != nil {
		arn := ackv1alpha1.AWSResourceName(*resp.TrainingJobArn)
		ko.Status.ACKResourceMetadata.ARN = &arn
	}

	rm.setStatusDefaults(ko)
	return &resource{ko}, nil
}

// newCreateRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Create API call for the resource
func (rm *resourceManager) newCreateRequestPayload(
	ctx context.Context,
	r *resource,
) (*svcsdk.CreateTrainingJobInput, error) {
	res := &svcsdk.CreateTrainingJobInput{}

	if r.ko.Spec.AlgorithmSpecification != nil {
		f0 := &svcsdktypes.AlgorithmSpecification{}
		if r.ko.Spec.AlgorithmSpecification.AlgorithmName != nil {
			f0.AlgorithmName = r.ko.Spec.AlgorithmSpecification.AlgorithmName
		}
		if r.ko.Spec.AlgorithmSpecification.EnableSageMakerMetricsTimeSeries != nil {
			f0.EnableSageMakerMetricsTimeSeries = r.ko.Spec.AlgorithmSpecification.EnableSageMakerMetricsTimeSeries
		}
		if r.ko.Spec.AlgorithmSpecification.MetricDefinitions != nil {
			f0f2 := []svcsdktypes.MetricDefinition{}
			for _, f0f2iter := range r.ko.Spec.AlgorithmSpecification.MetricDefinitions {
				f0f2elem := &svcsdktypes.MetricDefinition{}
				if f0f2iter.Name != nil {
					f0f2elem.Name = f0f2iter.Name
				}
				if f0f2iter.Regex != nil {
					f0f2elem.Regex = f0f2iter.Regex
				}
				f0f2 = append(f0f2, *f0f2elem)
			}
			f0.MetricDefinitions = f0f2
		}
		if r.ko.Spec.AlgorithmSpecification.TrainingImage != nil {
			f0.TrainingImage = r.ko.Spec.AlgorithmSpecification.TrainingImage
		}
		if r.ko.Spec.AlgorithmSpecification.TrainingInputMode != nil {
			f0.TrainingInputMode = svcsdktypes.TrainingInputMode(*r.ko.Spec.AlgorithmSpecification.TrainingInputMode)
		}
		res.AlgorithmSpecification = f0
	}
	if r.ko.Spec.CheckpointConfig != nil {
		f1 := &svcsdktypes.CheckpointConfig{}
		if r.ko.Spec.CheckpointConfig.LocalPath != nil {
			f1.LocalPath = r.ko.Spec.CheckpointConfig.LocalPath
		}
		if r.ko.Spec.CheckpointConfig.S3URI != nil {
			f1.S3Uri = r.ko.Spec.CheckpointConfig.S3URI
		}
		res.CheckpointConfig = f1
	}
	if r.ko.Spec.DebugHookConfig != nil {
		f2 := &svcsdktypes.DebugHookConfig{}
		if r.ko.Spec.DebugHookConfig.CollectionConfigurations != nil {
			f2f0 := []svcsdktypes.CollectionConfiguration{}
			for _, f2f0iter := range r.ko.Spec.DebugHookConfig.CollectionConfigurations {
				f2f0elem := &svcsdktypes.CollectionConfiguration{}
				if f2f0iter.CollectionName != nil {
					f2f0elem.CollectionName = f2f0iter.CollectionName
				}
				if f2f0iter.CollectionParameters != nil {
					f2f0elem.CollectionParameters = aws.ToStringMap(f2f0iter.CollectionParameters)
				}
				f2f0 = append(f2f0, *f2f0elem)
			}
			f2.CollectionConfigurations = f2f0
		}
		if r.ko.Spec.DebugHookConfig.HookParameters != nil {
			f2.HookParameters = aws.ToStringMap(r.ko.Spec.DebugHookConfig.HookParameters)
		}
		if r.ko.Spec.DebugHookConfig.LocalPath != nil {
			f2.LocalPath = r.ko.Spec.DebugHookConfig.LocalPath
		}
		if r.ko.Spec.DebugHookConfig.S3OutputPath != nil {
			f2.S3OutputPath = r.ko.Spec.DebugHookConfig.S3OutputPath
		}
		res.DebugHookConfig = f2
	}
	if r.ko.Spec.DebugRuleConfigurations != nil {
		f3 := []svcsdktypes.DebugRuleConfiguration{}
		for _, f3iter := range r.ko.Spec.DebugRuleConfigurations {
			f3elem := &svcsdktypes.DebugRuleConfiguration{}
			if f3iter.InstanceType != nil {
				f3elem.InstanceType = svcsdktypes.ProcessingInstanceType(*f3iter.InstanceType)
			}
			if f3iter.LocalPath != nil {
				f3elem.LocalPath = f3iter.LocalPath
			}
			if f3iter.RuleConfigurationName != nil {
				f3elem.RuleConfigurationName = f3iter.RuleConfigurationName
			}
			if f3iter.RuleEvaluatorImage != nil {
				f3elem.RuleEvaluatorImage = f3iter.RuleEvaluatorImage
			}
			if f3iter.RuleParameters != nil {
				f3elem.RuleParameters = aws.ToStringMap(f3iter.RuleParameters)
			}
			if f3iter.S3OutputPath != nil {
				f3elem.S3OutputPath = f3iter.S3OutputPath
			}
			if f3iter.VolumeSizeInGB != nil {
				volumeSizeInGBCopy0 := *f3iter.VolumeSizeInGB
				if volumeSizeInGBCopy0 > math.MaxInt32 || volumeSizeInGBCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field VolumeSizeInGB is of type int32")
				}
				volumeSizeInGBCopy := int32(volumeSizeInGBCopy0)
				f3elem.VolumeSizeInGB = &volumeSizeInGBCopy
			}
			f3 = append(f3, *f3elem)
		}
		res.DebugRuleConfigurations = f3
	}
	if r.ko.Spec.EnableInterContainerTrafficEncryption != nil {
		res.EnableInterContainerTrafficEncryption = r.ko.Spec.EnableInterContainerTrafficEncryption
	}
	if r.ko.Spec.EnableManagedSpotTraining != nil {
		res.EnableManagedSpotTraining = r.ko.Spec.EnableManagedSpotTraining
	}
	if r.ko.Spec.EnableNetworkIsolation != nil {
		res.EnableNetworkIsolation = r.ko.Spec.EnableNetworkIsolation
	}
	if r.ko.Spec.Environment != nil {
		res.Environment = aws.ToStringMap(r.ko.Spec.Environment)
	}
	if r.ko.Spec.ExperimentConfig != nil {
		f8 := &svcsdktypes.ExperimentConfig{}
		if r.ko.Spec.ExperimentConfig.ExperimentName != nil {
			f8.ExperimentName = r.ko.Spec.ExperimentConfig.ExperimentName
		}
		if r.ko.Spec.ExperimentConfig.TrialComponentDisplayName != nil {
			f8.TrialComponentDisplayName = r.ko.Spec.ExperimentConfig.TrialComponentDisplayName
		}
		if r.ko.Spec.ExperimentConfig.TrialName != nil {
			f8.TrialName = r.ko.Spec.ExperimentConfig.TrialName
		}
		res.ExperimentConfig = f8
	}
	if r.ko.Spec.HyperParameters != nil {
		res.HyperParameters = aws.ToStringMap(r.ko.Spec.HyperParameters)
	}
	if r.ko.Spec.InfraCheckConfig != nil {
		f10 := &svcsdktypes.InfraCheckConfig{}
		if r.ko.Spec.InfraCheckConfig.EnableInfraCheck != nil {
			f10.EnableInfraCheck = r.ko.Spec.InfraCheckConfig.EnableInfraCheck
		}
		res.InfraCheckConfig = f10
	}
	if r.ko.Spec.InputDataConfig != nil {
		f11 := []svcsdktypes.Channel{}
		for _, f11iter := range r.ko.Spec.InputDataConfig {
			f11elem := &svcsdktypes.Channel{}
			if f11iter.ChannelName != nil {
				f11elem.ChannelName = f11iter.ChannelName
			}
			if f11iter.CompressionType != nil {
				f11elem.CompressionType = svcsdktypes.CompressionType(*f11iter.CompressionType)
			}
			if f11iter.ContentType != nil {
				f11elem.ContentType = f11iter.ContentType
			}
			if f11iter.DataSource != nil {
				f11elemf3 := &svcsdktypes.DataSource{}
				if f11iter.DataSource.FileSystemDataSource != nil {
					f11elemf3f0 := &svcsdktypes.FileSystemDataSource{}
					if f11iter.DataSource.FileSystemDataSource.DirectoryPath != nil {
						f11elemf3f0.DirectoryPath = f11iter.DataSource.FileSystemDataSource.DirectoryPath
					}
					if f11iter.DataSource.FileSystemDataSource.FileSystemAccessMode != nil {
						f11elemf3f0.FileSystemAccessMode = svcsdktypes.FileSystemAccessMode(*f11iter.DataSource.FileSystemDataSource.FileSystemAccessMode)
					}
					if f11iter.DataSource.FileSystemDataSource.FileSystemID != nil {
						f11elemf3f0.FileSystemId = f11iter.DataSource.FileSystemDataSource.FileSystemID
					}
					if f11iter.DataSource.FileSystemDataSource.FileSystemType != nil {
						f11elemf3f0.FileSystemType = svcsdktypes.FileSystemType(*f11iter.DataSource.FileSystemDataSource.FileSystemType)
					}
					f11elemf3.FileSystemDataSource = f11elemf3f0
				}
				if f11iter.DataSource.S3DataSource != nil {
					f11elemf3f1 := &svcsdktypes.S3DataSource{}
					if f11iter.DataSource.S3DataSource.AttributeNames != nil {
						f11elemf3f1.AttributeNames = aws.ToStringSlice(f11iter.DataSource.S3DataSource.AttributeNames)
					}
					if f11iter.DataSource.S3DataSource.InstanceGroupNames != nil {
						f11elemf3f1.InstanceGroupNames = aws.ToStringSlice(f11iter.DataSource.S3DataSource.InstanceGroupNames)
					}
					if f11iter.DataSource.S3DataSource.S3DataDistributionType != nil {
						f11elemf3f1.S3DataDistributionType = svcsdktypes.S3DataDistribution(*f11iter.DataSource.S3DataSource.S3DataDistributionType)
					}
					if f11iter.DataSource.S3DataSource.S3DataType != nil {
						f11elemf3f1.S3DataType = svcsdktypes.S3DataType(*f11iter.DataSource.S3DataSource.S3DataType)
					}
					if f11iter.DataSource.S3DataSource.S3URI != nil {
						f11elemf3f1.S3Uri = f11iter.DataSource.S3DataSource.S3URI
					}
					f11elemf3.S3DataSource = f11elemf3f1
				}
				f11elem.DataSource = f11elemf3
			}
			if f11iter.InputMode != nil {
				f11elem.InputMode = svcsdktypes.TrainingInputMode(*f11iter.InputMode)
			}
			if f11iter.RecordWrapperType != nil {
				f11elem.RecordWrapperType = svcsdktypes.RecordWrapper(*f11iter.RecordWrapperType)
			}
			if f11iter.ShuffleConfig != nil {
				f11elemf6 := &svcsdktypes.ShuffleConfig{}
				if f11iter.ShuffleConfig.Seed != nil {
					f11elemf6.Seed = f11iter.ShuffleConfig.Seed
				}
				f11elem.ShuffleConfig = f11elemf6
			}
			f11 = append(f11, *f11elem)
		}
		res.InputDataConfig = f11
	}
	if r.ko.Spec.OutputDataConfig != nil {
		f12 := &svcsdktypes.OutputDataConfig{}
		if r.ko.Spec.OutputDataConfig.CompressionType != nil {
			f12.CompressionType = svcsdktypes.OutputCompressionType(*r.ko.Spec.OutputDataConfig.CompressionType)
		}
		if r.ko.Spec.OutputDataConfig.KMSKeyID != nil {
			f12.KmsKeyId = r.ko.Spec.OutputDataConfig.KMSKeyID
		}
		if r.ko.Spec.OutputDataConfig.S3OutputPath != nil {
			f12.S3OutputPath = r.ko.Spec.OutputDataConfig.S3OutputPath
		}
		res.OutputDataConfig = f12
	}
	if r.ko.Spec.ProfilerConfig != nil {
		f13 := &svcsdktypes.ProfilerConfig{}
		if r.ko.Spec.ProfilerConfig.ProfilingIntervalInMilliseconds != nil {
			f13.ProfilingIntervalInMilliseconds = r.ko.Spec.ProfilerConfig.ProfilingIntervalInMilliseconds
		}
		if r.ko.Spec.ProfilerConfig.ProfilingParameters != nil {
			f13.ProfilingParameters = aws.ToStringMap(r.ko.Spec.ProfilerConfig.ProfilingParameters)
		}
		if r.ko.Spec.ProfilerConfig.S3OutputPath != nil {
			f13.S3OutputPath = r.ko.Spec.ProfilerConfig.S3OutputPath
		}
		res.ProfilerConfig = f13
	}
	if r.ko.Spec.ProfilerRuleConfigurations != nil {
		f14 := []svcsdktypes.ProfilerRuleConfiguration{}
		for _, f14iter := range r.ko.Spec.ProfilerRuleConfigurations {
			f14elem := &svcsdktypes.ProfilerRuleConfiguration{}
			if f14iter.InstanceType != nil {
				f14elem.InstanceType = svcsdktypes.ProcessingInstanceType(*f14iter.InstanceType)
			}
			if f14iter.LocalPath != nil {
				f14elem.LocalPath = f14iter.LocalPath
			}
			if f14iter.RuleConfigurationName != nil {
				f14elem.RuleConfigurationName = f14iter.RuleConfigurationName
			}
			if f14iter.RuleEvaluatorImage != nil {
				f14elem.RuleEvaluatorImage = f14iter.RuleEvaluatorImage
			}
			if f14iter.RuleParameters != nil {
				f14elem.RuleParameters = aws.ToStringMap(f14iter.RuleParameters)
			}
			if f14iter.S3OutputPath != nil {
				f14elem.S3OutputPath = f14iter.S3OutputPath
			}
			if f14iter.VolumeSizeInGB != nil {
				volumeSizeInGBCopy0 := *f14iter.VolumeSizeInGB
				if volumeSizeInGBCopy0 > math.MaxInt32 || volumeSizeInGBCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field VolumeSizeInGB is of type int32")
				}
				volumeSizeInGBCopy := int32(volumeSizeInGBCopy0)
				f14elem.VolumeSizeInGB = &volumeSizeInGBCopy
			}
			f14 = append(f14, *f14elem)
		}
		res.ProfilerRuleConfigurations = f14
	}
	if r.ko.Spec.RemoteDebugConfig != nil {
		f15 := &svcsdktypes.RemoteDebugConfig{}
		if r.ko.Spec.RemoteDebugConfig.EnableRemoteDebug != nil {
			f15.EnableRemoteDebug = r.ko.Spec.RemoteDebugConfig.EnableRemoteDebug
		}
		res.RemoteDebugConfig = f15
	}
	if r.ko.Spec.ResourceConfig != nil {
		f16 := &svcsdktypes.ResourceConfig{}
		if r.ko.Spec.ResourceConfig.InstanceCount != nil {
			instanceCountCopy0 := *r.ko.Spec.ResourceConfig.InstanceCount
			if instanceCountCopy0 > math.MaxInt32 || instanceCountCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field InstanceCount is of type int32")
			}
			instanceCountCopy := int32(instanceCountCopy0)
			f16.InstanceCount = &instanceCountCopy
		}
		if r.ko.Spec.ResourceConfig.InstanceGroups != nil {
			f16f1 := []svcsdktypes.InstanceGroup{}
			for _, f16f1iter := range r.ko.Spec.ResourceConfig.InstanceGroups {
				f16f1elem := &svcsdktypes.InstanceGroup{}
				if f16f1iter.InstanceCount != nil {
					instanceCountCopy0 := *f16f1iter.InstanceCount
					if instanceCountCopy0 > math.MaxInt32 || instanceCountCopy0 < math.MinInt32 {
						return nil, fmt.Errorf("error: field InstanceCount is of type int32")
					}
					instanceCountCopy := int32(instanceCountCopy0)
					f16f1elem.InstanceCount = &instanceCountCopy
				}
				if f16f1iter.InstanceGroupName != nil {
					f16f1elem.InstanceGroupName = f16f1iter.InstanceGroupName
				}
				if f16f1iter.InstanceType != nil {
					f16f1elem.InstanceType = svcsdktypes.TrainingInstanceType(*f16f1iter.InstanceType)
				}
				f16f1 = append(f16f1, *f16f1elem)
			}
			f16.InstanceGroups = f16f1
		}
		if r.ko.Spec.ResourceConfig.InstanceType != nil {
			f16.InstanceType = svcsdktypes.TrainingInstanceType(*r.ko.Spec.ResourceConfig.InstanceType)
		}
		if r.ko.Spec.ResourceConfig.KeepAlivePeriodInSeconds != nil {
			keepAlivePeriodInSecondsCopy0 := *r.ko.Spec.ResourceConfig.KeepAlivePeriodInSeconds
			if keepAlivePeriodInSecondsCopy0 > math.MaxInt32 || keepAlivePeriodInSecondsCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field KeepAlivePeriodInSeconds is of type int32")
			}
			keepAlivePeriodInSecondsCopy := int32(keepAlivePeriodInSecondsCopy0)
			f16.KeepAlivePeriodInSeconds = &keepAlivePeriodInSecondsCopy
		}
		if r.ko.Spec.ResourceConfig.VolumeKMSKeyID != nil {
			f16.VolumeKmsKeyId = r.ko.Spec.ResourceConfig.VolumeKMSKeyID
		}
		if r.ko.Spec.ResourceConfig.VolumeSizeInGB != nil {
			volumeSizeInGBCopy0 := *r.ko.Spec.ResourceConfig.VolumeSizeInGB
			if volumeSizeInGBCopy0 > math.MaxInt32 || volumeSizeInGBCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field VolumeSizeInGB is of type int32")
			}
			volumeSizeInGBCopy := int32(volumeSizeInGBCopy0)
			f16.VolumeSizeInGB = &volumeSizeInGBCopy
		}
		res.ResourceConfig = f16
	}
	if r.ko.Spec.RetryStrategy != nil {
		f17 := &svcsdktypes.RetryStrategy{}
		if r.ko.Spec.RetryStrategy.MaximumRetryAttempts != nil {
			maximumRetryAttemptsCopy0 := *r.ko.Spec.RetryStrategy.MaximumRetryAttempts
			if maximumRetryAttemptsCopy0 > math.MaxInt32 || maximumRetryAttemptsCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field MaximumRetryAttempts is of type int32")
			}
			maximumRetryAttemptsCopy := int32(maximumRetryAttemptsCopy0)
			f17.MaximumRetryAttempts = &maximumRetryAttemptsCopy
		}
		res.RetryStrategy = f17
	}
	if r.ko.Spec.RoleARN != nil {
		res.RoleArn = r.ko.Spec.RoleARN
	}
	if r.ko.Spec.StoppingCondition != nil {
		f19 := &svcsdktypes.StoppingCondition{}
		if r.ko.Spec.StoppingCondition.MaxPendingTimeInSeconds != nil {
			maxPendingTimeInSecondsCopy0 := *r.ko.Spec.StoppingCondition.MaxPendingTimeInSeconds
			if maxPendingTimeInSecondsCopy0 > math.MaxInt32 || maxPendingTimeInSecondsCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field MaxPendingTimeInSeconds is of type int32")
			}
			maxPendingTimeInSecondsCopy := int32(maxPendingTimeInSecondsCopy0)
			f19.MaxPendingTimeInSeconds = &maxPendingTimeInSecondsCopy
		}
		if r.ko.Spec.StoppingCondition.MaxRuntimeInSeconds != nil {
			maxRuntimeInSecondsCopy0 := *r.ko.Spec.StoppingCondition.MaxRuntimeInSeconds
			if maxRuntimeInSecondsCopy0 > math.MaxInt32 || maxRuntimeInSecondsCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field MaxRuntimeInSeconds is of type int32")
			}
			maxRuntimeInSecondsCopy := int32(maxRuntimeInSecondsCopy0)
			f19.MaxRuntimeInSeconds = &maxRuntimeInSecondsCopy
		}
		if r.ko.Spec.StoppingCondition.MaxWaitTimeInSeconds != nil {
			maxWaitTimeInSecondsCopy0 := *r.ko.Spec.StoppingCondition.MaxWaitTimeInSeconds
			if maxWaitTimeInSecondsCopy0 > math.MaxInt32 || maxWaitTimeInSecondsCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field MaxWaitTimeInSeconds is of type int32")
			}
			maxWaitTimeInSecondsCopy := int32(maxWaitTimeInSecondsCopy0)
			f19.MaxWaitTimeInSeconds = &maxWaitTimeInSecondsCopy
		}
		res.StoppingCondition = f19
	}
	if r.ko.Spec.Tags != nil {
		f20 := []svcsdktypes.Tag{}
		for _, f20iter := range r.ko.Spec.Tags {
			f20elem := &svcsdktypes.Tag{}
			if f20iter.Key != nil {
				f20elem.Key = f20iter.Key
			}
			if f20iter.Value != nil {
				f20elem.Value = f20iter.Value
			}
			f20 = append(f20, *f20elem)
		}
		res.Tags = f20
	}
	if r.ko.Spec.TensorBoardOutputConfig != nil {
		f21 := &svcsdktypes.TensorBoardOutputConfig{}
		if r.ko.Spec.TensorBoardOutputConfig.LocalPath != nil {
			f21.LocalPath = r.ko.Spec.TensorBoardOutputConfig.LocalPath
		}
		if r.ko.Spec.TensorBoardOutputConfig.S3OutputPath != nil {
			f21.S3OutputPath = r.ko.Spec.TensorBoardOutputConfig.S3OutputPath
		}
		res.TensorBoardOutputConfig = f21
	}
	if r.ko.Spec.TrainingJobName != nil {
		res.TrainingJobName = r.ko.Spec.TrainingJobName
	}
	if r.ko.Spec.VPCConfig != nil {
		f23 := &svcsdktypes.VpcConfig{}
		if r.ko.Spec.VPCConfig.SecurityGroupIDs != nil {
			f23.SecurityGroupIds = aws.ToStringSlice(r.ko.Spec.VPCConfig.SecurityGroupIDs)
		}
		if r.ko.Spec.VPCConfig.Subnets != nil {
			f23.Subnets = aws.ToStringSlice(r.ko.Spec.VPCConfig.Subnets)
		}
		res.VpcConfig = f23
	}

	return res, nil
}

// sdkUpdate patches the supplied resource in the backend AWS service API and
// returns a new resource with updated fields.
func (rm *resourceManager) sdkUpdate(
	ctx context.Context,
	desired *resource,
	latest *resource,
	delta *ackcompare.Delta,
) (updated *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkUpdate")
	defer func() {
		exit(err)
	}()
	input, err := rm.newUpdateRequestPayload(ctx, desired, delta)
	if err != nil {
		return nil, err
	}
	warmpool_diff := delta.DifferentAt("Spec.ResourceConfig.KeepAlivePeriodInSeconds")
	profiler_diff := delta.DifferentAt("Spec.ProfilerConfig") || delta.DifferentAt("Spec.ProfilerRuleConfigurations")
	if warmpool_diff && profiler_diff {
		return latest, ackerr.NewTerminalError(errors.New("cannot update Warm pool and Profiler at the same time"))
	}
	if !warmpool_diff && !profiler_diff {
		return latest, ackerr.NewTerminalError(errors.New("only Warm Pool or Profiler can be updated"))
	}
	trainingSecondaryStatus := latest.ko.Status.SecondaryStatus
	if ackcompare.IsNotNil(trainingSecondaryStatus) && *trainingSecondaryStatus == string(svcsdktypes.SecondaryStatusStarting) {
		return nil, ackrequeue.NeededAfter(
			errors.New("training job cannot be updated while secondary status is in Starting state."),
			ackrequeue.DefaultRequeueAfterDuration,
		)
	}
	if warmpool_diff {
		input.ProfilerConfig = nil
		input.ProfilerRuleConfigurations = nil
		if err := rm.isWarmPoolUpdatable(latest); err != nil {
			return nil, err
		}
	}
	if profiler_diff {
		if err := rm.isProfilerUpdatable(latest); err != nil {
			return nil, err
		}
		input.ResourceConfig = nil
		if rm.isProfilerRemoved(desired, latest) {
			rm.handleProfilerRemoval(input)
		} else {
			if err := rm.customSetUpdateInput(desired, latest, delta, input); err != nil {
				return nil, err
			}
		}
	}

	var resp *svcsdk.UpdateTrainingJobOutput
	_ = resp
	resp, err = rm.sdkapi.UpdateTrainingJob(ctx, input)
	rm.metrics.RecordAPICall("UPDATE", "UpdateTrainingJob", err)
	if err != nil {
		return nil, err
	}
	// Merge in the information we read from the API call above to the copy of
	// the original Kubernetes object we passed to the function
	ko := desired.ko.DeepCopy()

	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if resp.TrainingJobArn != nil {
		arn := ackv1alpha1.AWSResourceName(*resp.TrainingJobArn)
		ko.Status.ACKResourceMetadata.ARN = &arn
	}

	rm.setStatusDefaults(ko)
	observed, err := rm.sdkFind(ctx, latest)
	if err != nil {
		return observed, err
	}
	ko.Status = observed.ko.Status
	return &resource{ko}, ackrequeue.NeededAfter(
		errors.New("training job is updating"),
		ackrequeue.DefaultRequeueAfterDuration,
	)
	return &resource{ko}, nil
}

// newUpdateRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Update API call for the resource
func (rm *resourceManager) newUpdateRequestPayload(
	ctx context.Context,
	r *resource,
	delta *ackcompare.Delta,
) (*svcsdk.UpdateTrainingJobInput, error) {
	res := &svcsdk.UpdateTrainingJobInput{}

	if r.ko.Spec.ProfilerConfig != nil {
		f0 := &svcsdktypes.ProfilerConfigForUpdate{}
		if r.ko.Spec.ProfilerConfig.ProfilingIntervalInMilliseconds != nil {
			f0.ProfilingIntervalInMilliseconds = r.ko.Spec.ProfilerConfig.ProfilingIntervalInMilliseconds
		}
		if r.ko.Spec.ProfilerConfig.ProfilingParameters != nil {
			f0.ProfilingParameters = aws.ToStringMap(r.ko.Spec.ProfilerConfig.ProfilingParameters)
		}
		if r.ko.Spec.ProfilerConfig.S3OutputPath != nil {
			f0.S3OutputPath = r.ko.Spec.ProfilerConfig.S3OutputPath
		}
		res.ProfilerConfig = f0
	}
	if r.ko.Spec.ProfilerRuleConfigurations != nil {
		f1 := []svcsdktypes.ProfilerRuleConfiguration{}
		for _, f1iter := range r.ko.Spec.ProfilerRuleConfigurations {
			f1elem := &svcsdktypes.ProfilerRuleConfiguration{}
			if f1iter.InstanceType != nil {
				f1elem.InstanceType = svcsdktypes.ProcessingInstanceType(*f1iter.InstanceType)
			}
			if f1iter.LocalPath != nil {
				f1elem.LocalPath = f1iter.LocalPath
			}
			if f1iter.RuleConfigurationName != nil {
				f1elem.RuleConfigurationName = f1iter.RuleConfigurationName
			}
			if f1iter.RuleEvaluatorImage != nil {
				f1elem.RuleEvaluatorImage = f1iter.RuleEvaluatorImage
			}
			if f1iter.RuleParameters != nil {
				f1elem.RuleParameters = aws.ToStringMap(f1iter.RuleParameters)
			}
			if f1iter.S3OutputPath != nil {
				f1elem.S3OutputPath = f1iter.S3OutputPath
			}
			if f1iter.VolumeSizeInGB != nil {
				volumeSizeInGBCopy0 := *f1iter.VolumeSizeInGB
				if volumeSizeInGBCopy0 > math.MaxInt32 || volumeSizeInGBCopy0 < math.MinInt32 {
					return nil, fmt.Errorf("error: field VolumeSizeInGB is of type int32")
				}
				volumeSizeInGBCopy := int32(volumeSizeInGBCopy0)
				f1elem.VolumeSizeInGB = &volumeSizeInGBCopy
			}
			f1 = append(f1, *f1elem)
		}
		res.ProfilerRuleConfigurations = f1
	}
	if r.ko.Spec.RemoteDebugConfig != nil {
		f2 := &svcsdktypes.RemoteDebugConfigForUpdate{}
		if r.ko.Spec.RemoteDebugConfig.EnableRemoteDebug != nil {
			f2.EnableRemoteDebug = r.ko.Spec.RemoteDebugConfig.EnableRemoteDebug
		}
		res.RemoteDebugConfig = f2
	}
	if r.ko.Spec.ResourceConfig != nil {
		f3 := &svcsdktypes.ResourceConfigForUpdate{}
		if r.ko.Spec.ResourceConfig.KeepAlivePeriodInSeconds != nil {
			keepAlivePeriodInSecondsCopy0 := *r.ko.Spec.ResourceConfig.KeepAlivePeriodInSeconds
			if keepAlivePeriodInSecondsCopy0 > math.MaxInt32 || keepAlivePeriodInSecondsCopy0 < math.MinInt32 {
				return nil, fmt.Errorf("error: field KeepAlivePeriodInSeconds is of type int32")
			}
			keepAlivePeriodInSecondsCopy := int32(keepAlivePeriodInSecondsCopy0)
			f3.KeepAlivePeriodInSeconds = &keepAlivePeriodInSecondsCopy
		}
		res.ResourceConfig = f3
	}
	if r.ko.Spec.TrainingJobName != nil {
		res.TrainingJobName = r.ko.Spec.TrainingJobName
	}

	return res, nil
}

// sdkDelete deletes the supplied resource in the backend AWS service API
func (rm *resourceManager) sdkDelete(
	ctx context.Context,
	r *resource,
) (latest *resource, err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.sdkDelete")
	defer func() {
		exit(err)
	}()
	latestStatus := r.ko.Status.TrainingJobStatus
	if latestStatus != nil {
		if *latestStatus == string(svcsdktypes.TrainingJobStatusStopping) {
			return r, requeueWaitWhileDeleting
		}

		// Call StopTrainingJob only if the job is InProgress, otherwise just
		// return nil to mark the resource Unmanaged
		if *latestStatus != string(svcsdktypes.TrainingJobStatusInProgress) {
			return r, err
		}
	}
	input, err := rm.newDeleteRequestPayload(r)
	if err != nil {
		return nil, err
	}
	var resp *svcsdk.StopTrainingJobOutput
	_ = resp
	resp, err = rm.sdkapi.StopTrainingJob(ctx, input)
	rm.metrics.RecordAPICall("DELETE", "StopTrainingJob", err)

	if err == nil {
		if observed, err := rm.sdkFind(ctx, r); err != ackerr.NotFound {
			if err != nil {
				return nil, err
			}
			r.SetStatus(observed)
			return r, requeueWaitWhileDeleting
		}
	}

	return nil, err
}

// newDeleteRequestPayload returns an SDK-specific struct for the HTTP request
// payload of the Delete API call for the resource
func (rm *resourceManager) newDeleteRequestPayload(
	r *resource,
) (*svcsdk.StopTrainingJobInput, error) {
	res := &svcsdk.StopTrainingJobInput{}

	if r.ko.Spec.TrainingJobName != nil {
		res.TrainingJobName = r.ko.Spec.TrainingJobName
	}

	return res, nil
}

// setStatusDefaults sets default properties into supplied custom resource
func (rm *resourceManager) setStatusDefaults(
	ko *svcapitypes.TrainingJob,
) {
	if ko.Status.ACKResourceMetadata == nil {
		ko.Status.ACKResourceMetadata = &ackv1alpha1.ResourceMetadata{}
	}
	if ko.Status.ACKResourceMetadata.Region == nil {
		ko.Status.ACKResourceMetadata.Region = &rm.awsRegion
	}
	if ko.Status.ACKResourceMetadata.OwnerAccountID == nil {
		ko.Status.ACKResourceMetadata.OwnerAccountID = &rm.awsAccountID
	}
	if ko.Status.Conditions == nil {
		ko.Status.Conditions = []*ackv1alpha1.Condition{}
	}
}

// updateConditions returns updated resource, true; if conditions were updated
// else it returns nil, false
func (rm *resourceManager) updateConditions(
	r *resource,
	onSuccess bool,
	err error,
) (*resource, bool) {
	ko := r.ko.DeepCopy()
	rm.setStatusDefaults(ko)

	// Terminal condition
	var terminalCondition *ackv1alpha1.Condition = nil
	var recoverableCondition *ackv1alpha1.Condition = nil
	var syncCondition *ackv1alpha1.Condition = nil
	for _, condition := range ko.Status.Conditions {
		if condition.Type == ackv1alpha1.ConditionTypeTerminal {
			terminalCondition = condition
		}
		if condition.Type == ackv1alpha1.ConditionTypeRecoverable {
			recoverableCondition = condition
		}
		if condition.Type == ackv1alpha1.ConditionTypeResourceSynced {
			syncCondition = condition
		}
	}
	var termError *ackerr.TerminalError
	if rm.terminalAWSError(err) || err == ackerr.SecretTypeNotSupported || err == ackerr.SecretNotFound || errors.As(err, &termError) {
		if terminalCondition == nil {
			terminalCondition = &ackv1alpha1.Condition{
				Type: ackv1alpha1.ConditionTypeTerminal,
			}
			ko.Status.Conditions = append(ko.Status.Conditions, terminalCondition)
		}
		var errorMessage = ""
		if err == ackerr.SecretTypeNotSupported || err == ackerr.SecretNotFound || errors.As(err, &termError) {
			errorMessage = err.Error()
		} else {
			awsErr, _ := ackerr.AWSError(err)
			errorMessage = awsErr.Error()
		}
		terminalCondition.Status = corev1.ConditionTrue
		terminalCondition.Message = &errorMessage
	} else {
		// Clear the terminal condition if no longer present
		if terminalCondition != nil {
			terminalCondition.Status = corev1.ConditionFalse
			terminalCondition.Message = nil
		}
		// Handling Recoverable Conditions
		if err != nil {
			if recoverableCondition == nil {
				// Add a new Condition containing a non-terminal error
				recoverableCondition = &ackv1alpha1.Condition{
					Type: ackv1alpha1.ConditionTypeRecoverable,
				}
				ko.Status.Conditions = append(ko.Status.Conditions, recoverableCondition)
			}
			recoverableCondition.Status = corev1.ConditionTrue
			awsErr, _ := ackerr.AWSError(err)
			errorMessage := err.Error()
			if awsErr != nil {
				errorMessage = awsErr.Error()
			}
			recoverableCondition.Message = &errorMessage
		} else if recoverableCondition != nil {
			recoverableCondition.Status = corev1.ConditionFalse
			recoverableCondition.Message = nil
		}
	}
	if syncCondition == nil && onSuccess {
		syncCondition = &ackv1alpha1.Condition{
			Type:   ackv1alpha1.ConditionTypeResourceSynced,
			Status: corev1.ConditionTrue,
		}
		ko.Status.Conditions = append(ko.Status.Conditions, syncCondition)
	}
	if terminalCondition != nil || recoverableCondition != nil || syncCondition != nil {
		return &resource{ko}, true // updated
	}
	return nil, false // not updated
}

// terminalAWSError returns awserr, true; if the supplied error is an aws Error type
// and if the exception indicates that it is a Terminal exception
// 'Terminal' exception are specified in generator configuration
func (rm *resourceManager) terminalAWSError(err error) bool {
	if err == nil {
		return false
	}

	var terminalErr smithy.APIError
	if !errors.As(err, &terminalErr) {
		return false
	}
	switch terminalErr.ErrorCode() {
	case "ResourceNotFound",
		"ResourceInUse",
		"InvalidParameterCombination",
		"InvalidParameterValue",
		"MissingParameter":
		return true
	default:
		return false
	}
}
